// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package sqlc

import (
	"context"
)

const deleteExpiredTerminalTasks = `-- name: DeleteExpiredTerminalTasks :execrows
DELETE FROM tasks
WHERE status IN ('succeeded', 'failed', 'timeout', 'canceled')
  AND expires_at_unix_ms > 0
  AND expires_at_unix_ms <= ?
`

func (q *Queries) DeleteExpiredTerminalTasks(ctx context.Context, expiresAtUnixMs int64) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteExpiredTerminalTasks, expiresAtUnixMs)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getTaskByID = `-- name: GetTaskByID :one
SELECT
    task_id,
    owner_id,
    request_id,
    capability,
    input_json,
    status,
    command_id,
    result_json,
    error_code,
    error_message,
    created_at_unix_ms,
    updated_at_unix_ms,
    deadline_at_unix_ms,
    completed_at_unix_ms,
    expires_at_unix_ms
FROM tasks
WHERE task_id = ?
LIMIT 1
`

func (q *Queries) GetTaskByID(ctx context.Context, taskID string) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskByID, taskID)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.OwnerID,
		&i.RequestID,
		&i.Capability,
		&i.InputJson,
		&i.Status,
		&i.CommandID,
		&i.ResultJson,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAtUnixMs,
		&i.UpdatedAtUnixMs,
		&i.DeadlineAtUnixMs,
		&i.CompletedAtUnixMs,
		&i.ExpiresAtUnixMs,
	)
	return i, err
}

const getTaskByOwnerAndRequest = `-- name: GetTaskByOwnerAndRequest :one
SELECT
    task_id,
    owner_id,
    request_id,
    capability,
    input_json,
    status,
    command_id,
    result_json,
    error_code,
    error_message,
    created_at_unix_ms,
    updated_at_unix_ms,
    deadline_at_unix_ms,
    completed_at_unix_ms,
    expires_at_unix_ms
FROM tasks
WHERE owner_id = ? AND request_id = ?
LIMIT 1
`

type GetTaskByOwnerAndRequestParams struct {
	OwnerID   string `json:"owner_id"`
	RequestID string `json:"request_id"`
}

func (q *Queries) GetTaskByOwnerAndRequest(ctx context.Context, arg GetTaskByOwnerAndRequestParams) (Task, error) {
	row := q.db.QueryRowContext(ctx, getTaskByOwnerAndRequest, arg.OwnerID, arg.RequestID)
	var i Task
	err := row.Scan(
		&i.TaskID,
		&i.OwnerID,
		&i.RequestID,
		&i.Capability,
		&i.InputJson,
		&i.Status,
		&i.CommandID,
		&i.ResultJson,
		&i.ErrorCode,
		&i.ErrorMessage,
		&i.CreatedAtUnixMs,
		&i.UpdatedAtUnixMs,
		&i.DeadlineAtUnixMs,
		&i.CompletedAtUnixMs,
		&i.ExpiresAtUnixMs,
	)
	return i, err
}

const insertTask = `-- name: InsertTask :exec
INSERT INTO tasks (
    task_id,
    owner_id,
    request_id,
    capability,
    input_json,
    status,
    command_id,
    result_json,
    error_code,
    error_message,
    created_at_unix_ms,
    updated_at_unix_ms,
    deadline_at_unix_ms,
    completed_at_unix_ms,
    expires_at_unix_ms
) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
`

type InsertTaskParams struct {
	TaskID            string `json:"task_id"`
	OwnerID           string `json:"owner_id"`
	RequestID         string `json:"request_id"`
	Capability        string `json:"capability"`
	InputJson         string `json:"input_json"`
	Status            string `json:"status"`
	CommandID         string `json:"command_id"`
	ResultJson        string `json:"result_json"`
	ErrorCode         string `json:"error_code"`
	ErrorMessage      string `json:"error_message"`
	CreatedAtUnixMs   int64  `json:"created_at_unix_ms"`
	UpdatedAtUnixMs   int64  `json:"updated_at_unix_ms"`
	DeadlineAtUnixMs  int64  `json:"deadline_at_unix_ms"`
	CompletedAtUnixMs int64  `json:"completed_at_unix_ms"`
	ExpiresAtUnixMs   int64  `json:"expires_at_unix_ms"`
}

func (q *Queries) InsertTask(ctx context.Context, arg InsertTaskParams) error {
	_, err := q.db.ExecContext(ctx, insertTask,
		arg.TaskID,
		arg.OwnerID,
		arg.RequestID,
		arg.Capability,
		arg.InputJson,
		arg.Status,
		arg.CommandID,
		arg.ResultJson,
		arg.ErrorCode,
		arg.ErrorMessage,
		arg.CreatedAtUnixMs,
		arg.UpdatedAtUnixMs,
		arg.DeadlineAtUnixMs,
		arg.CompletedAtUnixMs,
		arg.ExpiresAtUnixMs,
	)
	return err
}

const markTaskDispatched = `-- name: MarkTaskDispatched :execrows
UPDATE tasks
SET status = 'dispatched',
    updated_at_unix_ms = ?
WHERE task_id = ?
  AND status IN ('queued', 'dispatched', 'running')
`

type MarkTaskDispatchedParams struct {
	UpdatedAtUnixMs int64  `json:"updated_at_unix_ms"`
	TaskID          string `json:"task_id"`
}

func (q *Queries) MarkTaskDispatched(ctx context.Context, arg MarkTaskDispatchedParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, markTaskDispatched, arg.UpdatedAtUnixMs, arg.TaskID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const markTaskRunning = `-- name: MarkTaskRunning :execrows
UPDATE tasks
SET status = 'running',
    command_id = ?,
    updated_at_unix_ms = ?
WHERE task_id = ?
  AND status IN ('queued', 'dispatched', 'running')
`

type MarkTaskRunningParams struct {
	CommandID       string `json:"command_id"`
	UpdatedAtUnixMs int64  `json:"updated_at_unix_ms"`
	TaskID          string `json:"task_id"`
}

func (q *Queries) MarkTaskRunning(ctx context.Context, arg MarkTaskRunningParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, markTaskRunning, arg.CommandID, arg.UpdatedAtUnixMs, arg.TaskID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const markTaskTerminal = `-- name: MarkTaskTerminal :execrows
UPDATE tasks
SET status = ?,
    result_json = ?,
    error_code = ?,
    error_message = ?,
    updated_at_unix_ms = ?,
    completed_at_unix_ms = ?,
    expires_at_unix_ms = ?
WHERE task_id = ?
  AND status IN ('queued', 'dispatched', 'running')
`

type MarkTaskTerminalParams struct {
	Status            string `json:"status"`
	ResultJson        string `json:"result_json"`
	ErrorCode         string `json:"error_code"`
	ErrorMessage      string `json:"error_message"`
	UpdatedAtUnixMs   int64  `json:"updated_at_unix_ms"`
	CompletedAtUnixMs int64  `json:"completed_at_unix_ms"`
	ExpiresAtUnixMs   int64  `json:"expires_at_unix_ms"`
	TaskID            string `json:"task_id"`
}

func (q *Queries) MarkTaskTerminal(ctx context.Context, arg MarkTaskTerminalParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, markTaskTerminal,
		arg.Status,
		arg.ResultJson,
		arg.ErrorCode,
		arg.ErrorMessage,
		arg.UpdatedAtUnixMs,
		arg.CompletedAtUnixMs,
		arg.ExpiresAtUnixMs,
		arg.TaskID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
